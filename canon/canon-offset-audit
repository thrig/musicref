#!/usr/bin/env perl
#
# Calculate interval tension sum for parallel canonic themes under
# various offset counts and transpositions. (May come up with low
# tension values for lines that would not normally be permitted under
# various rule systems (parallel fifths or octaves, etc); something else
# would need to audit for such.)
#
# TODO support rhythm (Cope has equations and advice on this on
# subsequent pages to what used below).
#
# TODO also multiple lines against each other, as adding a 3rd or 4th
# line may change what offsets and transpositions create the overall
# most consonant combination.

use strict;
use warnings;

use Getopt::Long qw(GetOptions);
use List::Util qw(max min sum);
use Music::AtonalUtil ();

GetOptions(
  'inverse'       => \my $Flag_Inverse,
  'offset=i'      => \my $Flag_Offset,
  'show-tensions' => \my $Flag_Show_Tensions,
  'transpose=i'   => \my $Flag_Transpose,
) || die "error reading options";

# Interval tentions taken from "Computer Models of Musical Creativity",
# Cope, p.229-230, from least tension (0.0) to greatest (1.0).
my %tensions = (
  0  => 0.0,
  1  => 1.0,
  2  => 0.8,
  3  => 0.225,
  4  => 0.2,
  5  => 0.55,
  6  => 0.65,
  7  => 0.1,
  8  => 0.275,
  9  => 0.25,
  10 => 0.7,
  11 => 0.9,
);
# Intervals greater than octave more consonant by virtue of spread
my $octave_adjust = -0.02;

########################################################################
#
# MAIN

my $atu = Music::AtonalUtil->new;

my $theme;
# Assume semitone pitch numbers, else try to convert note names to such.
# (Notes in particular do not support registers, so must use semitone
# pitch numbers if need that.)
if ( $ARGV[0] =~ m/^\d+/ ) {
  $theme = \@ARGV;
} else {
  $theme = $atu->notes2pitches( \@ARGV );
}

my $min_offset    = 1;
my $max_offset    = min( int( @$theme / 2 ), 4 );
my $min_transpose = -19;
my $max_transpose = 19;

if ($Flag_Inverse) {
  $theme = canonic_inverse($theme);

  my $inverse_notes = $atu->pitches2notes($theme);
  warn "Inverse Theme: ", join( ' ', @$inverse_notes ), " ",
    join( ' ', @$theme ), "\n";
}
if ( defined $Flag_Offset ) {
  die
    "offset must be positive integer (and ideally less than length of theme)\n"
    if $Flag_Offset < 0
      or $Flag_Offset >= @$theme;
  $min_offset = $max_offset = $Flag_Offset;
}
if ( defined $Flag_Transpose ) {
  $min_transpose = $max_transpose = $Flag_Transpose;
}

for my $offset ( $min_offset .. $max_offset ) {
  for my $transpose ( $min_transpose .. $max_transpose ) {
    my @tensions;
    for my $i ( $offset .. $#$theme ) {
      push @tensions,
        tension( $theme->[$i], $theme->[ $i - $offset ] + $transpose );
    }
    my $max     = max(@tensions);
    my $min     = min(@tensions);
    my $tension = sum(@tensions);

    # compensate for fewer matching notes in larger offsets
    $tension /= @tensions;

    my $tension_str = "";
    $tension_str = " @tensions" if $Flag_Show_Tensions;

    printf
      "%.03f O(%d) T(% 2d)\tMin(%.03f) Max(%.03f) Mean(%.03f) SDev(%.03f)%s\n",
      $tension, $offset,
      $transpose, $min, $max, mean( \@tensions ),
      standard_deviation( \@tensions ),
      $tension_str;
  }
}

exit 0;

########################################################################
#
# SUBROUTINES

sub canonic_inverse {
  my ($theme) = @_;
  my @inverse_theme = $theme->[0];
  for my $i ( 1 .. $#$theme ) {
    my $delta = $theme->[$i] - $theme->[ $i - 1 ];
    $inverse_theme[$i] = $inverse_theme[ $i - 1 ] + ( -1 * $delta );
  }
  return \@inverse_theme;
}

# $mean = mean(\@array) computes the mean of an array of numbers.
sub mean {
  my $arrayref  = shift;
  my $sum       = shift;
  my $is_sample = shift // 0;
  my $n         = @$arrayref;
  $n-- if $is_sample;
  unless ($sum) {
    for (@$arrayref) { $sum += $_ }
  }
  return $sum / $n;
}

# $sd = standard_deviation_data(\@array) computes the standard
# deviation of an array of numbers.
sub standard_deviation {
  my $arrayref = shift;
  my $mean = shift || mean($arrayref);

  return sqrt( mean( [ map ( ( $_ - $mean )**2, @$arrayref ) ] ) );
}

sub tension {
  my ( $p1, $p2 ) = @_;
  my $interval = abs( $p2 - $p1 );
  my $octave   = int( $interval / $atu->scale_degrees );

  my $tension =
    $tensions{ $interval % $atu->scale_degrees } +
    ( $octave > 0 ? $octave_adjust : 0 );
  $tension = 0 if $tension < 0;

  return $tension;
}
